/*
 * UART.cpp
 *
 *  Created on: May 9, 2018
 *      Author: M
 */

#include <UART.h>
#include <string.h>

UART::UART() {
	// TODO Auto-generated constructor stub
	init();

}

UART::~UART() {
	// TODO Auto-generated destructor stub
}


/*!
 * \brief teken een lijn.
 * \param paramter int.
 */
int UART::write(char *text_out){
	volatile unsigned int i;
	for (i=0; text_out[i]; i++)
	{
		putchar(text_out[i]);
	}
}

/*!
 * \brief teken een lijn.
 * \param paramter int.
 */
int UART::read(char *buf){
	while (1)
	{
	 	*buf = getchar();

	 	if (*buf=='ÿ')             // check for data available
	 	{
	 		continue;
	 	}

	 	if (*buf==0xff | *buf == LF) // if no data or LF, continue
	 		continue;

		if (*buf==CR)            // if enter pressed
		{
			*buf = '\0';         // ignore char and close string
		    return 0;            // buf ready, exit loop
		}
		buf++;
	}
}

/*!
 * \brief teken een lijn.
 * \param paramter int.
 */
int UART::init(){
	  /* --------------------------- System Clocks Configuration -----------------*/
	  /* USART2 clock enable */
	  RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);

	  /* GPIOA clock enable */
	  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);

	  GPIO_InitTypeDef GPIO_InitStructure;

	  /*-------------------------- GPIO Configuration ----------------------------*/
	  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;
	  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
	  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	  GPIO_Init(GPIOA, &GPIO_InitStructure);

	  /* Connect USART pins to AF */
	  GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_USART2);   // USART2_TX
	  GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_USART2);  // USART2_RX

	  USART_InitTypeDef USART_InitStructure;

	/* USARTx configuration ------------------------------------------------------*/
	/* USARTx configured as follow:
	      - BaudRate = 115200 baud
	      - Word Length = 8 Bits
	      - One Stop Bit
	      - No parity
	      - Hardware flow control disabled (RTS and CTS signals)
	      - Receive and transmit enabled
	*/
	USART_InitStructure.USART_BaudRate = 115200;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;

	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

	USART_Init(USART2, &USART_InitStructure);
	USART_ITConfig(USART2,USART_IT_RXNE,ENABLE);

	USART_Cmd(USART2, ENABLE);
	NVIC_EnableIRQ(USART2_IRQn);

}

/*!
 * \brief teken een lijn.
 * \param paramter int.
 */
int UART::putchar(char c){
	while(USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET); // Wait for Empty
	USART_SendData(USART2, c);
}

/*!
 * \brief de VGA class
 */
char UART::getchar(void){
	char uart_char = -1;
	if (USART_GetFlagStatus(USART2, USART_FLAG_RXNE)== SET)  // check for data available
		uart_char= USART2->DR & 0xFF; // and read the data from peripheral
	return uart_char;
}

size_t USART_Send(USART_TypeDef *USARTx, void *buf, ssize_t l, uint8_t flags) {
	ssize_t i = 0;
	uint8_t idx;
	uint8_t *pBuf;

	pBuf = buf;

	/* Send with blocking mode. */
	if(flags == BLOCKING) {
		for(i=0; i<l; i++) {
			while(USART_GetFlagStatus(USARTx, USART_FLAG_TC) == RESET);
			USART_SendByte(USARTx, (uint16_t)(pBuf[i]));
		}
	}
	/* Send with non-blocking mode. */
	else if(flags == NON_BLOCKING) {
		for(i=0; i<MAX_USART_STREAM; i++) {
			idx = (i + usart_stream_idx) % MAX_USART_STREAM;
			if(usart_stream[idx].pBuf == NULL) {
				usart_stream[idx].pBuf = pBuf;
				usart_stream[idx].BufLen = l;
				/* Enable USART6 TX interrupt. */
				USART_ITConfig(USART6, USART_IT_TXE, ENABLE);
				break;
			}
		}
		if(i >= MAX_USART_STREAM)
			i = -1;
	}

	return i;
}

/* Print the string through USART with blocking. */
void USART_Printf(USART_TypeDef* USARTx, char *str) {
	USART_Send(USARTx, str, strlen(str), BLOCKING);
}

/* USART6 IRQ handler. */
void USART2_IRQHandler(void) {
	char c[] = "\0\r\n\0";
	uint8_t i;

	/* USART6 RX interrupt. */
	if(USART2->SR & USART_SR_RXNE) {
		c[0] = USART_ReadByte(USART2);

		USART_Printf(USART2, "Pressed key: ");
		USART_Printf(USART2, c);
	}

	/* USART6 TX interrupt. */
	if(USART2->SR & USART_SR_TXE) {
		if(usart_stream[usart_stream_idx].BufLen > 0) {
			USART_SendByte(USART2,
						   toupper(*usart_stream[usart_stream_idx].pBuf));
			usart_stream[usart_stream_idx].pBuf++;
			usart_stream[usart_stream_idx].BufLen--;
		}
		else {
			/* Current USART streaming is finished. */
			/* Release and clear current USART stream. */
			ClearStream(usart_stream + usart_stream_idx);
			/* Try to stream next USART stream which should be stream. */
			usart_stream_idx++;
			for(i=0; i<MAX_USART_STREAM; i++) {
				usart_stream_idx = (usart_stream_idx + i) % MAX_USART_STREAM;
				if(usart_stream[usart_stream_idx].pBuf != NULL)
					break;
			}
			/* Disable USART6 TX interrupt after all streams are finished. */
			if(i >= MAX_USART_STREAM)
				USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
		}
	}
}


